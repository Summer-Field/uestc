# 数据预处理技术

- 为什么需要预处理数据？

现实中的数据是脏的  --  Dirty Data

- 为什么要预处理数据？

数据缺失：记录为空&属性为空

数据重复：完全重复&不完全重复

数据错误：异常值&不一致

数据不可用：数据正确但是不可用



预防脏数据出现

- 订制数据标准

同一多数据源的属性值编码

尽可能赋予属性名和属性值明确的含义

- 优化系统设计

关键属性尽可能采用选项方式，而不是手动填写

重要属性出现在醒目的位置，并且采用必填选项

异常值给出修改提示



数据预处理

数据挖掘前，对原始数据进行必要的**清洗、集成、转换、规约**等一系列的处理后，达到挖掘算法进行只是获取研究所需要的最低标准

- 数据清洗：填补缺失数据、消除噪声
- 数据集成：将数据同一、去除冗余
- 数据变换：限定属性值
- 数据规约：缩小数据

## 4.1 数据清洗

### 4.1.1 处理缺失数据

- 缺失原因

设备异常

输入是不重要数据遗漏

- 缺失值处理

忽略

默认值

平均值

同类平均值

预测可能值

### 4.1.2 处理不一致数据

- 不一致原因

输入者习惯不佳

数据没有统一标准

- 不一致通过匹配进行修改

制定清晰规则表，进行匹配

通过统计描述、找到异常值

### 4.1.3 处理数据噪声

- 原因

数据记录过程中存在偏差

设备测量数据可能存在偏差

- 数据噪音处理

1. 分箱算法

分箱：将待处理的数据按照一定规则放进箱子中，考察每个箱子中的数据，采用某种方法分别对各个箱子中的数据进行处理

箱子：按照属性值划分的子区间，如果一个属性处于这个范围内，那么我们就把这个数据放在这个子区间的箱子中

主要面对的问题：

a. 分箱方法

等深分箱：按照个数来分

等宽分箱：按照数据范围来分

自定义区间：自定区间来分

b. 数据平滑方法，如何对每个箱子中的数据进行平滑处理

按平均值平滑：对同一个箱中的数据求平均值，用平均值代替箱中的所有数据

按边界值平滑：用距离比较小的边界值代替箱中的每一个数据

按中值平滑：取箱中的中值来代替箱子中的所有数据

2. 聚类算法

簇：一组数据对象集合。同一簇内的所有对象具有相似性，不同簇对象具有较大的差异性。

聚类：将物理的或者抽象的对象的集合分组为不同的簇，找出并清除那些落在簇外的值（孤立点），这些**孤立点就是噪声**

通过聚类发现异常数据：类似或相邻的数据聚合在一起形成了各个聚类集合，而那些位于这些集合之外的数据对象，自然就成了异常数据。

特点：直接形成簇并对他进行描述，不需要任何先验知识

3. 回归算法

回归：拟合函数来进行数据平滑

方法：

- 线性回归
- 非线性回归

## 4.2 数据集成

- 什么是数据集成？

将多个数据整合到一个一致的存储中

- 模式匹配
- 数据冗余
- 数据值冲突

### 4.2.1 模式匹配

- 实体识别问题：匹配来自不同数据源的现实世界实体

e.g: A.cust_id = B.customer_no

- 整合不同数据源中的元数据

### 4.2.2 数据冗余

- 同一属性的不同数据在不同的数据库有不同的字段名
- 一个属性可以由另外一个表或者其他的属性导出。

相关分析检测
$$
𝑟_(𝐴,𝐵)=(∑(𝐴−¯𝐴)(𝐵−¯𝐵))/((𝑛−1) 𝜎_𝐴 𝜎_𝐵 )
$$

### 4.2.3 数据值冲突

- 对于一个现实世界实体，来自不同数据源的属性值可能是不同的
- 产生原因：表示的差异、比例尺度不同、或编码的差异等。例如：重量属性在一个系统中采用公制，而在另一个系统中却采用英制。同样价格属性不同地点采用不同货币单位。

## 4.3 数据变换

### 4.3.1 平滑

- 去噪声，将连续数据离散化，增加粒度

分箱

聚类

回归

### 4.3.2 聚集

- 对数据进行汇总
  - avg(), count(), sum(), min(), max()....

### 4.3.3 数据概化

用更抽象（更高层次）的概念来替代低层次或数据层的数据对象

e.g：年龄->青年、中年、老年

### 4.3.4 规范化

将数据按比例进行缩放，使之落入一个特定的区域，以消除数值型属性因大小不一而造成挖掘结果的偏差。

-e.g：将工资收入的属性值映射到[-1,1]的范围内

- 方法

  1. 最小-最大规范化

     <img src="/Users/bytedance/uestc/big_data/note/pic/Picture4.png" alt="Picture4" style="zoom:50%;" />

     如果取值超过了范围，则系统会出错

  2. 零-均值规范化

  使用情况根据属性A的**均值和方差**来对A进行规格化,常用于属性最大值与最小值未知，或使用**最大最小规格化方法时会出现异常数据的情况**。
  $$
  𝑣^′=(𝑣−¯𝐴)/𝜎_𝐴 
  $$
  

  3. 小数定标规范化

  •该方法通过**移动属性A值的小数位置**来达到规格化的目的。所移动的小数位数取决于属性A绝对值的最大值。属性A的v值可以通过以下计算公式获得其映射值v′：

  
  $$
  v^′=v/10^j 
  $$
  其中的j为使max⁡(|v^′ |)<1成立的最小值。

### 4.3.5 属性构造

利用已有的属性构造出新的属性，并加入到现有的属性集合中帮助挖掘更深层次的模式知识，提高挖掘结果准确性

长，宽  -->  面积

- 构造合适的属性能够帮助**减少学习构造决策树**时所出现的碎块情况
- 通过属性结合可以**帮助发现所遗漏的属性之间的相互联系**，这对于数据挖掘过程是十分重要的

## 4.4 数据规约

- 对大规模数据库内容进行复杂的数据分析通常需要耗费大量的时间
- 数据规约技术可以帮助从原有的庞大数据集中获取精简数据集合，并使得这个精简的数据集保持原有的数据完整性，这样在数据挖掘显然效率更高，并且挖掘出来的结果与使用原有数据集的结果基本相同

### 数据规约标准

- 用于数据规约的时间不应当超过“抵消”在规约后的数据上挖掘节省的时间
- 规约的到的数据比原数据小很多，但是分析结果基本一致

### 数据规约方法

#### 1. 数据立方聚集

- 数据立方基本概念

数据立方体是数据的多维建模和表示，由维和事实组成

维：属性

事实：数据

- 数据立方体聚集定义
  - 将n维数据立方体聚集为n-1维的数据立方体
  - 解释：将n个属性规约为n-1个属性

#### 2. 维规约

- 维规约  --  去掉无关属性，减少数据挖掘处理的数据量
- 例如：挖掘顾客是否会在商场购买MP3，那么顾客的电话号码就是无关属性，可以去掉
- 目标：寻找出最小属性子集，并确保新数据子集的概率分布尽可能地接近原来的数据集概率分布

#### 3. 选择相关属性子集

- 逐步向前选择

从一个空属性集（作为属性子集初始值）开始，每次从原来属性集合中选择一个当前最优的属性添加到当前属性子集中。直到无法选择出最优属性或满足一定阈值约束为止。

- 逐步向后删除

从一个全属性集（作为属性子集的初始值）开始，每次从当前属性子集中选择一个当前最差的属性并将其从当前属性子集中消去。直到无法选择除最差属性为止或满足一定阈值约束为止。

- 向前选择和向后删除结合
- 判定树（决策树）归纳

利用决**策树的归纳方法**对初始数据进行分类归纳学习，获得一个**初始决策树**，所有没有出现这个决策树上的属性均认为是无关属性，因此将这些属性从初始属性集合删除掉，就可以获得一个较优的属性子集

- 基于统计分析的规约

#### 4. 数据压缩

数据压缩  --  用数据编码或者变换，得到原始数据的压缩表示

- 在数据挖掘领域通常使用的两种数据压缩方法均是有损的：

  - 主成分分析法

    假定待压缩的数据由*N*个取自*k*个维的元组或数据向量组成。主要成分分析并搜索得到*c*个最能代表数据的*k*维正交向量，这里 *c*≤*k*。这样就可以把原数据投影到一个较小的空间，实现数据压缩

  - 小波转换
    - 离散小波变换是一种线性信号处理技术，该技术方法可以将一个数据向量D转换为另一个具有相同长度的数据向量D^′，即小波相关系数。
    - 给定一组小波相关系数，利用离散小波变换的逆运算可以恢复原来的数据。
    - 舍弃部分数值低的小波系数后重建信号，相对于原始信号损失不大。因此保留大于某一阈值的小波系数，而将其它小波系数置为0，可以提高数据处理的运算效率。
    - 数值低的小波系数由噪声引起，因此这一技术可以实现数据清洗。
  - 傅里叶级数

<img src="/Users/bytedance/uestc/big_data/note/pic/Picture5.png" alt="Picture4" style="zoom:50%;" />

#### 5. 数值规约

数值归约  --  用较小的数据表示数据，或采用较短的数据单位，或者用数据模型代表数据，**减少数据量**

##### 1. 直方图

反映了频率-值的对应关系

##### 2.用聚类数据表示实际数据

分类分层选择数据

##### 3.抽样（采样）

- 优点：获取样本的时间仅与样本规模成正比
- 方法
  - 不放回简单随机抽样
  - 放回简单随机抽样
  - 聚类抽样：先聚类，再抽样
  - 分层抽样：先分层，再抽样

##### 4. 参数回归法

通常采用一个模型来评估数据，该方法只需要存放参数，而不是实际数据。能大大简少数据量，但只对数值型数据有效

- 方法：
  - 线性回归（Y=α+βx）
  - 非线性回归

## 4.5 离散化与概念分层生成

- 三种类型的属性值
  - 名称型  --  无序集合中的值
  - 序数  --  有序集合中的值
  - 连续值  --  实数
- 离散化技术
  - 以通过将属性（连续取值）阈值范围内分为若干区间，来帮助消减一个连续（取值）属性的取值个数

- 概念分层
  - 通过使用高层概念来替代底层概念（青年、中年、老年->具体的年龄值）来规约数据
  - 概念分层定义了一组由底层概念集到高层概念集的映射。用高层概念替代底层概念，就可以减少取值个数。随谈一些细节数据被泛化，但是这样的数据更易理解，更有意义。所以数据挖掘的效率更高
  - 可以使用树来表示，这样每个结点都代表一个概念

### 4.5.1 概念分层生成

#### 数值数据的概念分层生成方法

- 分箱

属性的值可以通过将其分配到各分箱中而将其离散化。利用分箱的均值、中位数替换每个分箱中的值（利用中值、均值来平滑）。循环应用这些操作处理每次操作结果，就可以获得一个概念层次树

- 直方图

循环应用直方图分析方法处理每次划分的结果，从而最终自动获得多层次概念树，而当达到用户指定层次水平后划分结束。

- 聚类

聚类算法可以将数据集划分为若干类或组。每个类构成了概念层次树的一个节点；每个类还可以进一步分解为若干子类，从而构成更低水平的层次。当然类也可以合并起来构成更高层次的概念水平。

#### 基于熵的离散化

- 数据按属性划分。S1,S2是S的一个划分且满足：A<T,A>=T
- 信息熵增益：

$$
𝐼(𝑆,𝑇)=|𝑆_1 |/|𝑆|  𝐸𝑛𝑡(𝑆_1 )+|𝑆_2 |/|𝑆|  𝐸𝑛𝑡(𝑆_2 )
$$

- 停止条件

$$
𝐸𝑛𝑡(𝑆)−𝐼(𝑆,𝑇)>𝛿
$$

#### 自然划分阶段

- 将数值区域划分为相对一致的、易于阅读的、看上去更直观或自然的区间。
  - [51263.98, 60872.34] -> [50000，60000]
- 划分方法： 3-4-5规则

如果一个区间最高有效位上包含**3，6，7或9**个不同的值，就将该区间划分为**3**个等宽子区间；(7->2,3,2)

如果一个区间最高有效位上包含**2，4，或8**个不同的值，就将该区间划分为**4**个等宽子区间；

如果一个区间最高有效位上包含**1，5，或10**个不同的值，就将该区间划分为**5**个等宽子区间；

将该规则递归的应用于每个子区间，产生给定数值属性的概念分层；

对于数据集中出现的最大值和最小值的极端分布，为了避免上述方法出现的结果扭曲，可以在**顶层分段**时，选用一个大部分的概率空间(如 5%-95%)，越出顶层分段的特别高和特别低的采用类似的方法形成单独的区间。

#### 4.5.2 类别概念层次树生成

- 类别属性可以取**有限个不同的值且这些值之间没有大小和顺序**

- 构造类别属性的概念层次树的主要方法：
  - 通过指定属性之间的**包含关系**产生分层
    - 街道/城市/省/国家
  - 对数据进行**分组（聚合）**产生分层
    - 江苏、安徽、山东->华东地区；广东、附件->华南地区
  - 属性值的个数产生分层
    - 定义属性的一个高水平概念通常包含了比一个低层次概念所包含要少一些的不同值
    - 拥有最多不同值的属性被放到层次树最低层；拥有的不同值数目越少在概念层次树上所放的层次越高

> 示例：假设用户针对商场地点（location）属性选择了一组属性：街道（street）、城市（city）、省（province）和国家（country）。但没有说明这些属性的层次顺序关系。

- 首先根据每个属性不同值的数目从小到大进行排序，Country（15）、Province（65）、City（3567）和Street（674,339）。

  - 根据所排顺序自顶而下构造层次树，即第一个属性在最高层，最后一个属性在最低层。

  - 最后用户对自动生成的概念层次树进行检查，必要时进行修改以使其能够反映所期望的属性间相互关系。



- 根据数据语义产生分层
  - 有时用户只能够提供概念层次树中的一部分属性，例如肢体通street、city，但是数据库模式定义可以根据属性间的语义联系，帮助构造层次树涉及的所有属性



>  **示例：**假设一个数据库系统将以下五个属性联系在一起：门牌（number）、街道（street）、城市（city）、省（province）和国家（country）。这五个属性与地点（location）属性密切相关。

- 用户仅说明地点属性的概念层次树中有城市属性，系统应能自动抽取出上述五个属性来构造层次树。

- 用户可以**除去概念层次树中的门牌（number）和街道（street）两个属性**，城市（city）属性就成为概念层次树中的最底层内容。
